# 第8章 用智能的编译器来防错
## 8.1 自动实现的属性
自动属性可用于“普通属性”，“普通属性”指可读/可写并将值存储到一个非常直观的私有变量中的属性，不做任何校验，也没有其他自定义代码。
写自己的结构时，如果使用自动属性，那么会有一个小问题：所有构造函数都需要显式地调用一下无参构造函数this()，只有这样，编译器才知道所有字段都被明确赋值了。由于字段是匿名的，所以不能直接设置它们。同时，在所有字段都被设置之前，也不能使用这些属性。如果要使用属性，唯一的办法就是调用无参构造函数，它会将字段设成它们的默认值。
```c#
public struct Foo
{
    public int Value { get; private set; }

    public Foo(int value) : this()
    {
        this.Value = value;
    }
}
```
## 8.2 隐式类型的局部变量
### 隐式类型的限制
* 被声明的变量是一个局部变量，而不是静态字段和实例字段
* 变量在声明的同时被初始化
* 初始化表达式不是方法组，也不是匿名函数(如果不尽兴强制类型转换)
* 初始化表达式不是null
* 语句中只声明了一个变量
* 你希望变量拥有的类型是初始化表达式的编译时类型
* 初始化表达式不包含正在声明的变量
```c#
//对于第3点和第4点可能有以下情况
var starter = (ThreadStart) delegate() { Console.WriteLine(); };
//但是，如果这样写，最好一开始就显式声明变量。
```
### 隐式类型的优缺点
优点：
* 不仅减少了代码的输入量，还减少了屏幕上显示的代码量（这就意味着可读性增强）。
* 读取代码时，相同的长类型名称在同一行上没必要出现两次——如果它们显然应该是同一个类型的话。
* 使用var还改变了代码的重心，将读者的注意力从变量的声明转移到使用上——是代码做了什么，而不是怎么做。

缺点：
* 隐式类型可能会影响可读性，假如不显式地指出要声明的变量是什么类型，只通过读代码的方式，可能不好确定它的类型。这打破了我们“先声明，再赋值”的这种将声明和初始化相分离的思维习惯。

### 建议
* 如果让读代码的人一眼就能看出变量的类型是很重要的，就使用显式类型
* 如果变量直接用一个构造函数初始化，而且类型名称很长(用泛型时经常会这样)，就考虑使用隐式类型
* 如果变量的确切类型不重要，而且它的本质在当前上下文中已很清楚，就用隐式类型，从而不去强调代码具体是如何达到其目标的，而是关注它想要达到什么目标这个更高级别的主题。
* 在开发一个新项目的时候，与团队成员就这件事情进行商议
* 如有疑虑，一行代码用两种方式都写一写，根据直觉选一个最“顺眼”的。

## 8.3 简化的初始化
### 集合初始化器
使用集合初始化器，代码简洁了很多
集合初始化列表并非只能应用于列表。任何实现了IEnumerable的类型，只要它为初始化列表中出现的每个元素都提供了一个恰当的公有的Add方法，就可以使用这个特性。
```c#
Person tom = new Person   //调用无参数构造函数
{
    Name = "Tom",   //直接设置属性
    Age = 9,
    Home = { Town = "Reading", Country = "UK" },   //初始化嵌入对象
    Friends =
    {
         new Person { Name = "Alberto" },   //用更进一步的对象初始化程序来初始化集合
         new Person("Max"),
         new Person { Name = "Zak", Age = 7 },
         new Person("Ben"),
         new Person("Alice"),
         {
             Age = 9,
             Home = { Town = "Twyford", Country = "UK" }
         }
     }
};
```
## 8.5 匿名类型
### 匿名类型的成员
匿名类型由编译器创建并包含到最终的程序集中。编译器还以同样的方式处理匿名方法和迭代器块所涉及的额外类型。CLR把它们看做普通的类型。
匿名类型包含以下成员：
* 一个获取所有初始值的构造函数。参数的顺序和它们在匿名对象初始化程序中的顺序一样，名称和类型也一样
* 公有的只读属性
* 属性的私有只读字段
* 重写的Equals、GetHashCode和ToString

同一个匿名类型的两个实例在判断相等性时，采用的是自然的方式：用属性类型的Equals方法来依次比较每个属性值。散列码的生成也是相似的：依次为每个属性值调用GetHashCode，并组合结果。
### 投影初始化程序
如果不指定属性名称，而是只指定用于求值的表达式，它就会使用表达式的最后一个部分作为名称——前提是它只能是一个简单字段或属性。这就是所谓的投影初始化程序（projection initializer）。
```c#
List<Person> family = new List
{
    new Person { Name = "Holly", Age = 36 },
    new Person { Name = "Jon", Age = 36 },
    new Person { Name = "Tom", Age = 9 },
    new Person { Name = "Robin", Age = 6 },
    new Person { Name = "William", Age = 6 }
};
var converted = family.ConvertAll(delegate(Person person)
    { return new { person.Name, IsAdult = (person.Age >= 18) }; }
);
foreach (var person in converted)
{
    Console.WriteLine("{0} is an adult? {1}",
                       person.Name, person.IsAdult);
}
```
