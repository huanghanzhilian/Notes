# 第10章 扩展方法
## 10.2 扩展方法的语法
并不是任何方法都能作为扩展方法使用——它必须具有以下特征：
* 它必须在一个非嵌套的、非泛型的静态类中（所以必须是一个静态方法）；
* 它至少要有一个参数；
* 第一个参数必须附加this关键字作为前缀；
* 第一个参数不能有其他任何修饰符（比如out或ref）；
* 第一个参数的类型不能是指针类型。

我们将第一个参数的类型称为方法的扩展类型（extended type），即指该方法扩展了该类型。

## 10.3 .NET 3.5中的扩展方法
> **效率问题：缓冲和流式技术**
> 框架提供的扩展方法会尽量尝试对数据进行“流式”（stream）或者说“管道”（pipe）传输。要求一个迭代器提供下一个元素时，它通常会从它链接的迭代器获取一个元素，处理那个元素，再返回符合要求的结果，而不用占用自己更多的存储空间。执行简单的转换和过滤操作时，这样做非常简单，可用的数据处理起来也非常高效。但是，对于某些操作来说，比如反转或排序，就要求所有数据都处于可用状态，所以需要加载所有数据到内存来执行批处理。缓冲和管道传输方式，这两者的差别很像是加载整个DataSet读取数据和用一个DataReader来每次处理一条记录的差别。使用LINQ时务必想好真正需要的是什么，一个简单的方法调用可能会严重影响性能。
> 流式传输（streaming）也叫惰性求值（lazy evaluation），缓冲传输（bufferring）也叫热情求值（eager evaluation）。例如，Reverse方法使用了延迟执行（deferred execution），它在第一次调用MoveNext之前不做任何事情。但随后却热切地（eagerly）对数据源求值。

## 10.4 使用思路和原则
### 流畅接口
流畅接口的背后理念——如果把代码逐字逐句地读出来，它的作用应该跃然“屏”上，好像本来就是用自然语言写成的一样。
写流畅接口时，可能要求思维方式发生改变。方法名有违传统的“描述性动词”形式，像“And”、“Then”和“If”这样的词有时适合作为流畅接口中的方法名。方法本身一般只是为将来的调用建立一个上下文。对于它们返回的类型来说，通常唯一的作用就是充当调用之间的一座桥梁。
### 理智使用扩展方法
* 开发团队中的每个人都应该理解扩展方法，并且知道在什么地方可以使用它们。要尽可能地避免让代码维护人员感到“突兀”。
* 将扩展方法放到它们自己的命名空间，可有效防止被误用。这样一来，即使读代码的时候不是那么一目了然，至少写它的开发者会注意到他正在做的事情。用项目或公司那一级的名称来定义这个命名空间的名称。甚至可以更进一步，为每个被扩展类型都使用一个单独的命名空间。例如，可以为扩展了System.Type的类创建一个TypeExtensions命名空间。
* 在扩展广泛使用的类型（如数字、object等）之前，或编写扩展类型实际为类型参数这样的扩展方法之前，要深思熟虑。有些指导书会尽可能地建议你不要这样做。而我认为这样的扩展方法可以存在，但必须值得存在。在这种情况下，将扩展方法设计为内部的或放置于自己的命名空间中，这一点就显得更加重要：我可不希望在每次使用整数时，智能感知都会提示June这个扩展方法。只有在那些使用了与日期和时间相关的扩展方法的类中，我才希望这样。
* 写扩展方法应该始终是一个有意识的决定，不要把它培养成一个习惯。绝对不是每个静态方法都该变成一个扩展方法。
* 在文档中指出第一个参数（在该值上调用扩展方法）是否允许为null——如果不允许，就在方法中检查值，并在必要的时候抛出一个异常（Argument Null Exception）。
* 注意，如果方法名已经在扩展类型中使用，就不要再使用这个名称。如果扩展类型是框架中的类型，或者来自某个第三方库，请在库的版本发生改变时检查自己的所有扩展方法。也许你很幸运，新旧方法的含义完全相同（就像Stream.CopyTo一样）。但即便如此，你还是应该删除这个扩展方法。
* 想一想它们是否影响了自己的编程效率。和隐式类型一样，强迫自己使用一个不喜欢的功能是没有多大意义的。
* 将应用于同一个扩展类型的扩展方法分组到一个静态类中。有的时候，相关的类（比如DateTime和TimeSpan）的扩展方法可以分组到一起。但是，如果扩展方法作用于迥然不同的类型（比如Stream和string），就不要把它们分组到同一个类中了。
* 在两个不同的命名空间中添加名字相同、扩展类型也相同的两个扩展方法时一定要三思，尤其是在两个方法都适用（它们有相同数量的参数）的情况下。合理的做法是添加或删除一个using指令，就可以使程序构建失败。但是，即使添加或删除一个using指令，程序也能构建，只是行为可能已经发生了变化，这样就比较烦人了。