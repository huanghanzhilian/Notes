# 第2章 C# 1所搭建的核心基础
## 2.1 委托
要在恰当的时间执行一系列操作，但不知道操作细节，一般可以使用委托。
### 简单委托的构成
委托必须满足4个条件
* 声明委托类型
* 必须有一个方法包含了要执行的代码
* 必须创建一个委托实例
* 必须调用(invoke)委托实例
  如果委托操作的是实例方法，这个对象称为操作的目标，会为这个对象调用(invoke)方法。
> invoke和call的区别
> 在执行一个信息都已知的方法时，用call比较恰当，这些信息包括要引用的类型、方法的签名及方法名。
> 在需要先“唤出”某个东西来帮你调用一个信息不明的方法时，用invoke比较恰当。

>必须注意， 假如委托实例本身不能被回收， 委托实例会阻止它的目标被作为垃圾回收。 这可能造成明显的内存泄漏（ leak） ， 尤其是假如某“短命”对象调用了一个“长命”对象中的事件， 并用它自身作为目标。 “长命”对象间接容纳了对“短命”对象的一个引用， 延长了“短命”对象的寿命。
### 合并和删除委托
> 委托是不易变的   
> 创建了委托实例后，有关它的一切就不能改变。这样一来，就可以安全地传递委托实例的引用，并把它们与其他委托实例合并，同时不必担心一致性、线程安全性或者是否有其他人试图更改它。增加和删除调用都返回新的委托对象，在执行前可以先创建副本，再对副本进行调用可以保证线程安全。

调用委托实例时，它的所有操作都顺序执行。如果委托的签名具有一个非void的返回类型，则Invoke的返回值是最后一个操作的返回值。很少有非void的委托实例在它的调用列表中指定多个操作，因为这意味着其他所有操作的返回值永远都看不见。除非每次调用代码使用Delegate.GetInvocationList获取操作列表时，都显式调用某个委托。
如果调用列表中的任何操作抛出一个异常，都会阻止执行后续的操作。
将事件看做类似于属性（property）的东西是很有好处的。首先，两者都声明为具有一种特定的类型。对于事件来说，必须是一个委托类型。
“事件”存在的首要理由和“属性”差不多——它们添加了一个封装层，实现发布/订阅模式（publish/subscribe pattern）
### 委托总结
* 委托封装了包含特殊返回类型和一组参数的行为，类似包含单一方法的接口
* 委托类型声明中所描述的类型签名决定了哪个方法可用于创建委托实例，同时决定了调用的签名
* 为了创建委托实例，需要一个方法以及（对于实例方法来说）调用方法的目标
* 委托实例是不易变的
* 每个委托实例都包含一个调用列表——一个操作列表
* 委托实例可以合并到一起，也可以从一个委托实例中删除另一个
* 事件不是委托实例——只是成对的add/remove方法（类似于属性的取值方法/赋值方法）

## 2.2 类型系统的特征
C# 1的类型系统是静态的、显式的和安全的。(有些强类型的定义中禁止任何形式的转换)
C# 4引入了动态类型，然而大多数C# 4引用程序中的大部分代码仍然是静态类型的。
### 显示类型和隐式类型
显式类型和隐式类型的区别只有在静态类型的语言中才有意义。对于显式类型来说，每个变量的类型都必须在声明中显式指明。隐式类型则允许编译器根据变量的用途来推断变量的类型。
> 接口实现和方法覆盖不支持返回类型的协变性，正常的解决方法是使用显式接口实现（explicit interface implementation）来获得预期的效果。
> 参数类型的逆变性也是不支持的。对于接口，解决方案是一样的，同样都是进行显式接口实现。对于虚方法，解决方案则是进行普通的方法重载。
```c#
public Person Clone()
{
    [Implementation goes here]
}
object ICloneable.Clone()    //显式实现接口
{
    return Clone();    //调用 非接口方法
}
```
### 类型系统总结
* C# 1是静态类型的——编译器知道你能使用哪些成员；
* C# 1是显式的——必须告诉编译器变量具有什么类型；
* C# 1是安全的——除非存在真实的转换关系，否则不能将一种类型当做另一种类型；
* 静态类型仍然不允许一个集合成为强类型的“字符串列表”或者“整数列表”，除非针对不同的元素使用大量的重复代码；
* 方法覆盖和接口实现不允许协变性/逆变性。

## 2.3 值类型和引用类型
* 数组类型是引用类型，即使元素类型是值类型（所以即便int是值类型，int[]仍是引用类型）
* 枚举（使用enum来声明）是值类型
* 委托类型（使用delegate来声明）是引用类型
* 接口类型（使用interface来声明）是引用类型，但可由值类型实现

对于引用类型的表达式，它的值是一个引用，而不是该引用所指代的对象
值类型不可以派生出其他类型，值不需要额外的信息来描述值实际是什么类型。
引用类型对象的开头都包含一个数据块，它标识了对象的实际类型，同时还提供了其他一些信息。永远都不能改变对象的类型——执行简单的强制类型转换时，运行时会获取一个引用，检查它引用的对象是不是目标类型的一个有效对象。如果有效，就返回原始引用；否则抛出异常。引用本身并不知道对象的类型——所以同一个引用“值”可用于（引用）不同类型的多个变量。
### 误区
* 值类型保存在栈上，引用类型保存在堆上
  前半句是错误的。
  变量的值在它声明时的位置存储。局部变量的值总是存储在栈（stack）中，实例变量的值总是存储在实例本身存储的地方。引用类型实例（对象）总是存储在堆（heap）中，静态变量也是。
  假定一个类中有一个int类型的实例变量，那么在这个类的任何对象中，该变量的值总是和对象中的其他数据在一起，也就是在堆上。
* 对象在C#中默认是通过引用传递的
如果以引用传递的方式来传送一个变量，那么调用的方法可以通过更改其参数值，来改变调用者的变量值。
引用类型变量的值是引用，而不是对象本身。不需要按引用来传递参数本身，就可以更改该参数引用的那个对象的内容。
```c#
void AppendHello(StringBuilder builder)
{
    builder.Append("hello");
}
```
调用这个方法时，参数值（对StringBuilder的一个引用）是以值传递（pass by value）的方式传递的。如果想在方法内部更改builder变量的值——如执行builder = null;语句，更改的是builder值的一个副本，这个改变调用者是看不见的。
### 小结
* 对于引用类型的表达式（如一个变量），它的值是一个引用，而非对象
* 引用就像URL——是允许你访问真实信息的一小片数据
* 对于值类型的表达式，它的值是实际的数据
* 有时，值类型比引用类型更有效，有时恰好相反
* 引用类型的对象总是在堆上，值类型的值既可能在栈上，也可能在堆上，具体取决于上下文
* 引用类型作为方法参数使用时，参数默认是以“值传递”方式来传递的——但值本身是一个引用
* 值类型的值会在需要引用类型的行为时被装箱；拆箱则是相反的过程。

## 2.4 C# 1之外：构建于监视基础之上的新特性
### 与委托有关的特性
* 泛型（泛型委托类型）——C# 2；
* 创建委托实例时使用的表达式——C# 2；
* 匿名方法——C# 2；
* 委托协变性/逆变性——C# 2；
* Lambda表达式——C# 3。

### 与类型系统有关的特性
* 泛型——C# 2；
* 受限的委托协变性/逆变性——C# 2；
* 匿名类型——C# 3；
* 隐式类型——C# 3；
* 扩展方法——C# 3；
* 受限的泛型协变/逆变——C# 4；
* 动态类型——C# 4。

### 与值类型有关的特性
* 泛型——C# 2；
* 可空类型（可以为null的类型）——C# 2。