<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>	
</head>
<body>
	<h1>过渡效果</h1>
	<h2>概述</h2>
	<hr>
	<p>Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。包括以下工具：</p>
	<ul>
		<li>在 CSS 过渡和动画中自动应用 class</li>
		<li>可以配合使用第三方 CSS 动画库，如 Animate.css</li>
		<li>在过渡钩子函数中使用 JavaScript 直接操作 DOM</li>
		<li>可以配合使用第三方 JavaScript 动画库，如 Velocity.js</li>
	</ul>
	<h2>单元素/组件的过渡</h2>
	<hr>
	<p>Vue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加 entering/leaving 过渡</p>
	<ul>
		<li>条件渲染 （使用 v-if）</li>
		<li>条件展示 （使用 v-show）</li>
		<li>动态组件</li>
		<li>组件根节点</li>
	</ul>
	<div id="demo">
		<button @click="show=!show">Toggle</button>
		<transition name="fade">
			<p v-if="show">hello</p>
		</transition>
	</div>
	<p>元素封装成过渡组件之后，在遇到插入或删除时，Vue 将</p>
	<ol>
		<li>自动嗅探目标元素是否有 CSS 过渡或动画，并在合适时添加/删除 CSS 类名。</li>
		<li>如果过渡组件设置了过渡的 JavaScript 钩子函数，会在相应的阶段调用钩子函数。</li>
		<li>如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作（插入/删除）在下一帧中立即执行。(注意：此指浏览器逐帧动画机制，与 Vue，和Vue的 nextTick 概念不同)</li>
	</ol>
	<h3>过渡的CSS类名</h3>
	<p>会有 4 个(CSS)类名在 enter/leave 的过渡中切换</p>
	<ol>
		<li><span>v-enter</span>: 定义进入过渡的开始状态。在元素被插入时生效，在下一个帧移除。</li>
		<li><span>v-enter-active</span>:定义进入过渡的结束状态。在元素被插入时生效，在<span>transition/animation</span>完成之后移除。</li>
		<li><span>v-leave</span>定义离开过渡的开始状态。在离开过渡被触发时生效，在下一个帧移除。</li>
		<li><span>v-leave-active</span>: 定义离开过渡的结束状态。在离开过渡被触发时生效，在<span>transition/animation</span>完成之后移除。</li>
	</ol>
	<p>这些在
		<span>enter/leave</span>过渡中切换的类名，
		<span>v-</span>是这些类名的前缀。使用
		<span><transition name="my-transition"></span>可以重置前缀，比如
		<span>v-enter</span>替换为
		<span>my-transition-enter</span>。
		<span>v-enter-active</span>和
		<span>v-leave-active</span>可以控制进入/离开过渡的不同阶段。
	</p>
	<h3>CSS过渡</h3>
	<div id="demo2">
		<button @click="show=!show">Toggle render</button>
		<transition name="slide-fade">
			<p v-if="show">hello</p>
		</transition>
	</div>
	<h3>CSS动画</h3>
	<p>CSS 动画用法同 CSS 过渡，区别是在动画中 v-enter 类名在节点插入 DOM 后不会立即删除，而是在 animationend 事件触发时删除。</p>
	<div id="demo3">
		<button @click="show=!show">Toggle Show</button>
		<transition name="bounce">
			<p v-if="show">look at me</p>
		</transition>
	</div>
	<h3>自定义过渡类名</h3>
	<p>我们可以通过以下特性来自定义过渡类名</p>
	<ul>
		<li>enter-class</li>
		<li>enter-active-class</li>
		<li>leave-class</li>
		<li>leave-active-class</li>
	</ul>
	<div id="demo4">
		<button @click="show=!show">Toggle render</button>
		<transition name="custom-classes-transition" enter-active-class="animated tada" leave-active-class="animated bounceOutRight">
			<p v-if="show">hello</p>
		</transition>
	</div>
	<h3>同时使用Transitions和Animations</h3>
	<p>Vue 为了知道过渡的完成，必须设置相应的事件监听器。它可以是 transitionend 或 animationend ，这取决于给元素应用的 CSS 规则。如果你使用其中任何一种，Vue 能自动识别类型并设置监听。</p>
	<p>但是，在一些场景中，你需要给同一个元素同时设置两种过渡动效，比如 animation 很快的被触发并完成了，而 transition 效果还没结束。在这种情况中，你就需要使用 type 特性并设置 animation 或 transition 来明确声明你需要 Vue 监听的类型。</p>
	<h3>JavaScript钩子</h3>
	<textarea rows="20" cols="80">
&lttransition
	v-on:before-enter="beforeEnter"
	v-on:enter="enter"
	v-on:after-enter="afterEnter"
	v-on:enter-cancelled="enterCancelled"
	v-on:before-leave="beforeLeave"
	v-on:leave="leave"
	v-on:after-leave="afterLeave"
	v-on:leave-cancelled="leaveCancelled"
&gt
&lt!-- ... --&gt
&lt/transition&gt


// ...
methods: {
  // --------
  // 进入中
  // --------
  beforeEnter: function (el) {
    // ...
  },
  // 此回调函数是可选项的设置
  // 与 CSS 结合时使用
  enter: function (el, done) {
    // ...
    done()
  },
  afterEnter: function (el) {
    // ...
  },
  enterCancelled: function (el) {
    // ...
  },
  // --------
  // 离开时
  // --------
  beforeLeave: function (el) {
    // ...
  },
  // 此回调函数是可选项的设置
  // 与 CSS 结合时使用
  leave: function (el, done) {
    // ...
    done()
  },
  afterLeave: function (el) {
    // ...
  },
  // leaveCancelled 只用于 v-show 中
  leaveCancelled: function (el) {
    // ...
  }
}
	</textarea>
	<p>这些钩子函数可以结合 CSS transitions/animations 使用，也可以单独使用。</p>
	<p>当只用 JavaScript 过渡的时候， 在 enter 和 leave 中，回调函数 done 是必须的 。 否则，它们会被同步调用，过渡会立即完成。</p>
	<p>推荐对于仅使用 JavaScript 过渡的元素添加 v-bind:css="false"，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。</p>
	<h3>一个使用Velocity.js的案例</h3>
	<div id="demo5">
		<button @click="show=!show">Toggle</button>
		<transition
			v-on:before-enter="beforeEnter"
			v-on:enter="enter"
			v-on:leave="leave"
			v-bind:css="false"
		>
			<p v-if="show">Demo</p>
		</transition>
	</div>
	<h2>初始渲染的过渡</h2>
	<hr>
	<p>可以通过appear特性设置节点的初始渲染的过渡</p>
	<textarea name="" id="" cols="80" rows="10">
<transition
  appear
  appear-class="custom-appear-class"
  appear-active-class="custom-appear-active-class"
>
  <!-- ... -->
</transition>
	</textarea>
	<p>自定义JavaScript钩子</p>
	<textarea name="" id="" cols="80" rows="10">
<transition
  appear
  v-on:before-appear="customBeforeAppearHook"
  v-on:appear="customAppearHook"
  v-on:after-appear="customAfterAppearHook"
>
  <!-- ... -->
</transition>
	</textarea>

	<h2>多个元素过渡</h2>
	<hr>
	<p>当有相同标签名的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。即使在技术上没有必要，给在 &lttransition&gt 组件中的多个元素设置 key 是一个更好的实践。</p>
	<textarea name="" id="" cols="80" rows="30">
<transition>
  <button v-if="isEditing" key="save">
    Save
  </button>
  <button v-else key="edit">
    Edit
  </button>
</transition>
可以给通过同一个元素的key特性设置不同的状态来代替v-if和v-else，可重写为
<transition>
  <button v-bind:key="isEditing">
    {{ isEditing ? 'Save' : 'Edit' }}
  </button>
</transition>
使用多个 v-if 的多个元素的过渡可以重写为绑定了动态属性的单个元素过渡。
<transition>
  <button v-if="docState === 'saved'" key="saved">
    Edit
  </button>
  <button v-if="docState === 'edited'" key="edited">
    Save
  </button>
  <button v-if="docState === 'editing'" key="editing">
    Cancel
  </button>
</transition>
重写为
<transition>
  <button v-bind:key="docState">
    {{ buttonMessage }}
  </button>
</transition>
<script type="text/javascript">
	// ...
computed: {
  buttonMessage: function () {
    switch (docState) {
      case 'saved': return 'Edit'
      case 'edited': return 'Save'
      case 'editing': return 'Cancel'
    }
  }
}
</script>
	</textarea>
	<h3>过渡模式</h3>
	<p>&lttransition&gt中当前元素的离开过渡和新元素的进入过渡是同时发生的，这不能满足所有的要求，Vue提供了过渡模式</p>
	<dl>
		<dt>in-out:</dt>
		<dd>新元素先进行过渡，完成之后当前元素过渡离开</dd>
		<dt>out-in：</dt>
		<dd>当前元素先进行过渡，完成之后新元素过渡进入</dd>
	</dl>	
	<textarea name="" id="" cols="80" rows="10">
<transition name="fade" mode="out-in">
  <!-- ... the buttons ... -->
</transition>
	</textarea>
	<p>多个组件的过渡很简单很多 - 我们不需要使用 key 特性。相反，我们只需要使用动态组件:</p>
	<div id="demo6">
	<input v-model="view" type="radio" value="v-a" id="a" name="view"><label for="a">A</label>
  	<input v-model="view" type="radio" value="v-b" id="b" name="view"><label for="b">B</label>
		<transition name="component-fade" mode="out-in">
			<component :is="view"></component>
		</transition>
	</div>
</body>
<script type="text/javascript" src="Scripts/vue.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js"></script>
<link href="https://unpkg.com/animate.css@3.5.1/animate.min.css" rel="stylesheet" type="text/css">
<script>
	var vm1=new Vue({
		el:"#demo",
		data:{show:true}
	})

	var vm2=new Vue({
		el:"#demo2",
		data:{show:true}
	})

	var vm3=new Vue({
		el:"#demo3",
		data:{show:true}
	})

	var vm4=new Vue({el:"#demo4",data:{show:true}});

	var vm5=new Vue({
		el:"#demo5",
		data:{show:true},
		methods:{
			beforeEnter:function(el){
				el.style.opacity = 0
				el.style.transformOrigin='left'
			},
			enter:function(el,done){
				Velocity(el,{opacity:1,fontSize:'1.4em'},{duration:300})
			},
			leave:function(el,done){
				Velocity(el,{translateX:'15px',rotateZ:'50deg'},{duration:600})
				Velocity(el,{rotateZ:'100deg'},{loop:2})
				Velocity(el,{
					rotateZ:'45deg',
					translateX:'30px',
					translateY:'30px',
					opacity:0
				},{
					complete:done
				})
			}
		}
	});

	var vm6=new Vue({
		el:"#demo6",
		data:{
			view:'v-a'
		},
		components:{
			'v-a':{
				template:'<div>Component A</div>'
			},
			'v-b':{
				template:'<div>Component B</div>'
			}
		}
	})
</script>
<style type="text/css">
	.fade-enter-active,.fade-leave-active{
		transition: opacity .5s
	}
	.fade-enter,.fade-leave-active{
		opacity: 0
	}
	
	.slide-fade-enter-active{
		transition: all .3s ease;
	}
	.slide-fade-leave-active{
		transition: all .8s cubic-bezier(1.0,0.5,0.8,1.0);
	}
	.slide-fade-enter,.slide-fade-leave-active{
		transform: translateX(10px);
		opacity: 0;
	}

	.bounce-enter-active{
		animation: bounce-in .5s;
	}
	.bounce-leave-active{
		animation: bounce-out .5s;
	}
	@keyframes bounce-in{
		0% {
			transform: scale(0);
		}
		50% {
			transform: scale(1.5);
		}
		100% {
			transform: scale(1);
		}
	}
	@keyframes bounce-out{
		0% {
			transform: scale(1);
		}
		50% {
			transform: scale(1.5);
		}
		100% {
			transform: scale(0);
		}
	}

	.component-fade-enter-active, .component-fade-leave-active {
		transition: opacity .3s ease;
	}
	.component-fade-enter, .component-fade-leave-active {
		opacity: 0;
	}
</style>
</html>