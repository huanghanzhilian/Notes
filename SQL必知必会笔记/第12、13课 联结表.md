# 第12课 联结表
## 12.2 创建联结
> 笛卡尔积(cartesian product)
> 由没有联结条件的表关系返回的结果为笛卡儿积。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数。

> 要保证所有联结都有WHERE 子句，否则DBMS将返回比想要的数据多得多的数据。同理，要保证WHERE 子句的正确性。不正确的过滤条件会导致DBMS返回不正确的数据。
> 有时，返回笛卡儿积的联结，也称叉联结（cross join）。

> 性能考虑
> DBMS在运行时关联指定的每个表，以处理联结。这种处理可能非常耗费资源，因此应该注意，不要联结不必要的表。联结的表越多，性能下降越厉害。

# 第13课 创建高级联结
## 13.1 使用表别名
SQL除了可以对列名和计算字段使用别名，还允许给表名起别名。这样做有两个主要理由：
* 缩短SQL语句；
* 允许在一条SELECT 语句中多次使用相同的表。
## 13.2 使用不同类型的联结 
### 自联结
```sql
--假如要给与Jim Jones同一公司的所有顾客发送一封信件。
--这个查询要求首先找出Jim Jones工作的公司，然后找出在该公司工作的顾客。
SELECT c1.cust_id, c1.cust_name, c1.cust_contact
FROM Customers AS c1, Customers AS c2
WHERE c1.cust_name = c2.cust_name
 AND c2.cust_contact = 'Jim Jones';
```
> 用自联结而不用子查询
> 自联结通常作为外部语句，用来替代从相同表中检索数据的使用子查询语句。虽然最终的结果是相同的，但许多DBMS处理联结远比处理子查询快得多。应该试一下两种方法，以确定哪一种的性能更好。

### 自然联结
无论何时对表进行联结，应该至少有一列不止出现在一个表中（被联结的列）。标准的联结（前一课中介绍的内联结）返回所有数据，相同的列甚至多次出现。自然联结排除多次出现，使每一列只返回一次。
自然联结要求你只能选择那些唯一的列，一般通过对一个表使用通配符（SELECT * ），而对其他表的列使用明确的子集来完成。
```sql
SELECT C.*, O.order_num, O.order_date,
       OI.prod_id, OI.quantity, OI.item_price
FROM Customers AS C, Orders AS O, OrderItems AS OI
WHERE C.cust_id = O.cust_id
 AND OI.order_num = O.order_num
 AND prod_id = 'RGAN01';
```

### 外联结
使用了关键字OUTER JOIN 来指定联结类型（而不是在WHERE 子句中指定）。但是，与内联结关联两个表中的行不同的是，外联结还包括没有关联行的行。在使用OUTER JOIN 语法时，必须使用RIGHT 或LEFT 关键字指定包括其所有行的表（RIGHT 指出的是OUTER JOIN 右边的表，而LEFT 指出的是OUTER JOIN 左边的表）。

总是有两种基本的外联结形式：左外联结和右外联结。它们之间的唯一差别是所关联的表的顺序。换句话说，调整FROM 或WHERE 子句中表的顺序，左外联结可以转换为右外联结。因此，这两种外联结可以互换使用，哪个方便就用哪个。

## 13.4 使用联结和联结条件
* 注意所使用的联结类型。一般我们使用内联结，但使用外联结也有效。
* 关于确切的联结语法，应该查看具体的文档，看相应的DBMS支持何种语法（大多数DBMS使用这两课中描述的某种语法）。
* 保证使用正确的联结条件（不管采用哪种语法），否则会返回不正确的数据。
* 应该总是提供联结条件，否则会得出笛卡儿积。
* 在一个联结中可以包含多个表，甚至可以对每个联结采用不同的联结类型。虽然这样做是合法的，一般也很有用，但应该在一起测试它们前分别测试每个联结。这会使故障排除更为简单。

