# 第6章 继承

## 6.1 派生
* 基类可以直接赋值给派生类(隐式转换)，而基类赋值给派生类时需要执行显式转换，并且可能会失败。

> **定义自定义转换**
> 类型间的装欢并不限于单一继承链中的类型。完全不相关的类型互相之间也能进行转换。关键在于两个类型之间提供转型操作符。C#允许类型包含显示或隐式转型操作符。在转型可能失败时，开发者应该定义显式转型操作符。

```c#
class GPSCoordinates{
  //方法表示从GPSCoordinates向UTMCoordinates的隐式转换。
  //将implicit替换成explicit就是显示转换
  public static implicit operator UTMCoordinates(GPSCoordinates coordinates){
    //...
  }
}
```

* 根据封装原则，派生类不能访问基类的private成员。例外情况是派生类是基类的嵌套类。
* 使用protected修饰符定义的成员只有基类和派生类才能访问。
* 扩展方法从技术上说不是类型的成员，所以不可继承。但是派生类可作为基类的实例使用，所以对一个类型进行扩展的方法也可扩展它的任何派生类型。

> 很少为基类写扩展方法。扩展方法的基本原则是：如果有基类的代码，直接修改基类会更好；如果基类代码不可用，应该考虑在基类或个别派生类实现的接口上添加扩展方法。

* C#是但继承的，在极少数需要多继承类结构的时候，一般的解决方案是使用聚合(aggregation)，即将一个类包含另一个类的实例。缺点在于，在字段类(private)上新增任何方法都需要人工添加到派生类中，否则派生类无法公开新增的功能
* 类使用sealed修饰符之后禁止派生，如string类

## 6.2 基类的重写

* C#支持重写实例方法和属性，但不支持重写字段或者任何静态成员。为了进行重写要求在基类中将允许重写的每个成员标记为virtual，而在派生类中则用关键字override进行修饰。
* 使用new关键字来隐藏基类的成员
* 使用sealed修饰符同时能够禁止派生类重写需成员
* 可以使用base关键字来调用基类成员

> 用override修饰的任何方法都自动称为虚方法。只能对基类的虚方法进行重写，所以重写获得的方法也是虚方法。

* 实例化一个派生类时，会先调用基类的构造器。

## 6.3 抽象类
* 抽象类代表抽象的实体，其抽象成员定义了从抽象实体派生的对象应包含什么，但这种成员不包含实现。抽象成员必须被重写，因此会自动成为虚成员，但不能用virtual关键字显示声明。

> 相同签名的成员在不同的类中有不同的实现，这称为**多态性**(polymorphism)
> 基本设计思想为：只有对象自己才知道如何最好的执行特定操作，通过规定调用这些操作的通用方式，多态性还促进了代码重用，因为通用的东西不必重复编码。