# 第8章 值类型
> 两种自定义值类型：结构、枚举
> 值类型直接包含值，变量引用的位置就是值在内存中十几储存的位置。将一个原始变量的值赋给另一个变量，会在新变量的位置创建原始变量的值的一个副本。方法内部对参数值进行任何修改都不会影响调用者中的原始值。
> 由于值类型需要有一个内存副本，所以定义时通常不要让它们消耗太多内存，不要创建消耗内存大于16字节的值类型。

## 8.1 结构
* 定义自定义值类型使用的适合定义类及接口相似的语法，使用关键字struct
* 确保值类型是不可变的是一种良好的规范，要创建不可变的值类型，要修改已实例化的值类型应创建新实例。
* 构造器必须初始化结构中的所有字段
* 结构不支持终结器
* 所有值类型都隐式密封，都派生自System.ValueType
* 值类型也能实现接口

> **规范**
> 如果值类型的相等性有意义，要重载值类型的相等性操作符(Equals()、==和!=)。还要考虑实现IEquatable<T>接口。

## 8.2 装箱
* 值类型转换成引用类型称为装箱，反之称为拆箱
* 装箱过程：堆上分配内存-》内存复制-》返回堆上新储存位置的引用
> lock语句中的值类型
> lock语句会被编译成Enter()和Exit()两个方法，必须成对调用。Enter()记录由其唯一的引用型参数传递的一个lock，使用相同的引用调用Exit()的时候，就可以释放该lock。值类型在Enter()或者Exit()时都会进行装箱，在堆上创建新值，比较两个副本的引用总是返回false，无法将Enter()与Exit()钩到一起。
> 不允许在lock()语句中使用值类型。

## 8.3 枚举
* 枚举是可由开发者声明的值类型，特征是编译时声明了一组可以通过名称来引用的常量值，这使代码更易读。
* 用枚举代替布尔值能改善可读性。
* 枚举值实际是作为证书常量出现的。默认的第一个枚举值是0，后续每项都递增1.
* 枚举的基础类型可以是除char外的任意整型。默认基础类型是int，可以通过继承语法来制定其他类型

```c#
enum ConnectionState : short
{
  Disconnected
}
```

* 从枚举值转成基础类型以及从基础类型转成枚举都需要显示转换，0例外，0能隐式转换成任何枚举。

> 考虑在现有枚举中添加新成员，但要注意兼容性风险
> 避免创建代表，“不完整”值(如版本号)集合的枚举
> 避免在枚举中创建“保留给将来用”的值
> 避免包含单个值的枚举。要为简单枚举提供0值(代表无)。注意若不显式地进行初始化，就默认从0开始

* 枚举作为标志使用

![枚举作为标志使用](E:/code/电子书/笔记/c%23本质论笔记/枚举作为标志使用.JPG)

* 要检查枚举是否包含某个值，使用System.Enum.IsDefined()方法

> 要用FlagAttribute指出枚举包含标志
> 要为所有的标志枚举提供等于0的none值
> 避免标志枚举中的零值时除了“所有标志都未设置”之外的其他意思。
> 考虑为常用标志组合提供特殊值
> 不要包含“哨兵”值(如Maximum)，这种值会使用户感到困扰
> 要用2的幂确保所有标志组合都不重复

> FlagAttribute
> 如果决定使用位标志枚举，枚举的声明应该用FlagAttribute进行标记。这个特性指出枚举值可以组合。
> 它改变了ToString()和Parse()方法的行为

自定义值类型(struct)平时用的比较少，只有在需要与托管代码进行互操作的时候，才需要大量地用到自定义结构。