# 第14章 支持标准查询操作符的集合接口
有两套与集合相关的类和接口：支持泛型的和不支持泛型的。通常，只有在你写的组件需要与老版本的“运行时”交互时，才应该使用不支持泛型的集合类。这是由于任何非泛型的东西，现在都有了 一个强类型的泛型代替物(在Silverlight和WinRT中，非泛型集合已被移除)。
## 14.1 匿名类型和隐式类型的局部变量声明
匿名类型纯粹是一个C#语言特性，当编译器遇到匿名类型语法的时候，会自动生成一个CIL类。
隐式类型的变量要少用，只有在付给变量的类型是显而易见的前提下，才使用隐式类型的局部变量。
两个匿名类型要在同一个程序集中做到类型兼容，属性名称、数据类型和属性顺序都必须完全匹配。
匿名类型是不可变的，匿名类型一经实例化，更改它的某个属性，就会造成编译错误。
编译器在生成匿名类型的代码时，重写了ToString()、Equals()和GetHashCode()方法的实现，所以一旦改变属性的顺序，就会生成一个全新的数据类型。
## 14.2 集合初始化器
集合初始化器要想编译成功，理性情况下应该实现ICollection<T>接口，这样可以确保集合包含Add()方法，除此之外还可以在实现了IEnumerable<T>的类型上包含一个或多个Add方法，Add方法需要接受与集合初始化器中指定的值兼容的参数。

* 匿名类型不能使用集合初始化器，集合初始化器要求执行一次构造器调用，但是不能给匿名类型的构造器命名。
> 解决方案
> 1. 定义`static List<T> CreateList<T>(T t){return new List<T>();r}`方法，利用类型推导来创建
> 2. 使用数组初始化器

## 14.3 是什么使类称为集合：IEnumerable<T>
.NET中集合本质上是一个类，最起码实现了IEnumerable<T>(或者非泛型IEnumerable)
并不是所有集合都包含已知数量的元素，不支持按照索引获取元素，迭代器(iterator)模式提供了一种更常规的方式遍历元素集合，只要能确定第一个元素、下一个元素和最后一个元素，就不需要实现知道元素总数，也不需要按照索引获取元素。
IEnumerable<T>和非泛型IEnumerable接口的设计目标就是允许迭代器模式来遍历元素集合，而不是使用长度-索引(length-index)模式。
IEnumerable<T>派生自IEnumerator、IEnumerable<T>和IDisposable接口，派生自IEnumerator提供移动到下一个元素的MoveNext()方法、返回当前元素的Current只读属性，IEnumerable<T>提供GetEnumerator()方法返回枚举数，负责维护循环遍历的状态。
在foreach循环期间对集合进行修改，重新访问枚举数enumerator就会引发异常
## 14.4 标准查询操作符
实现IEnumerable<T>的任何类型只需实现GetEnumrator()这一个方法，之后有超过50个方法可供使用，这些方法都来自于Enumerable类。IEnumerable<T>上的方法都是一个标准查询操作符(standard query operator)，用于为所操作的集合提供的集合提供查询功能。
> LINQ查询的并行运行
> 使用AsParallel()方法，“运行时”一边遍历集合，一边返回结果

* 推迟执行
  在LINQ标准查询操作符的上下文中，每个Lambda表达式都构成了要执行的总体查询的一部分。Lambda表达式在声明时不执行。
> 为了避免重复触发Lambda表达式，一个查询在执行之后，有必要把它获取的数据缓存起来，可以使用ToXXX方法将数据赋给一个局部集合，这样会执行查询，之后对集合进行遍历就不会触发Lambda表达式了。

> 不要为OrderBy()的结果再次调用OrderBy()，附加的排序依据用ThenBy()来指定

* IQuerable<T>
IQuerable<T>派生自IEnumerable<T>,可以通过它实现自定义的LINQ Provider。
LINQ Provider的作用是将表达式分解成各个组成部分，一经分解，表达式就可以转换成另一种语言。