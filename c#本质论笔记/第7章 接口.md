# 第7章 接口
## 7.1 接口概述
* 接口的关键特点是既不包含实现，也不包含数据。方法声明时用分号代替大括号，字段不能再接口声明中出现。如果接口要求派生类包含特定数据，会声明属性而不是字段。
* C#不允许为接口成员使用访问修饰符，所有成员都自动定义为公共成员

> 接口名称要使用Pascal大小写风格，并以“I”作为前缀。

## 7.3 接口实现
* 声明类以实现接口，类似于从基类派生--要实现的接口和基类的名称以逗号分隔(基类在前，接口的顺序任意)。类可以实现多个接口，但只能从一个基类直接派生。
* 接口不能实例化，不包含静态成员
* 接口的显式实现只能通过接口本身调用成员，隐式实现可直接调用成员

```c#
    public interface ITest
    {
        string Name { get; }
    }

    public class Test : ITest
    {
        //给成员前加上前缀来显式实现接口
        string ITest.Name
        {
            get
            {
                return "显式实现接口";
            }
        }
    }

    public class Test2 : ITest
    {
        //隐式实现接口，成员必须是public，还可以选择virtual
        public string Name
        {
            get
            {
                return "隐式实现接口";
            }
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Test t = new Test();
            //显示实现只能通过接口本身调用
            //需将对象转为接口，再调用成员
            Console.WriteLine(((ITest)t).Name);

            Test2 t2 = new Test2();
            //隐式实现可以直接调用成员
            Console.WriteLine(t2.Name);
        }
    }
```
> 显示还是隐式实现接口的基本设计原则
> * 成员是不是核心的类功能
> * 接口成员名作为类名是否恰当
> * 是否已经具有相同的签名的类成员

避免显示实现接口成员，除非有很好的理由。但如果不确定成员的用途，就先选择显示实现。
## 7.4 在实现类和接口之间转换
* 实现接口的类可隐式转换成以实现的接口
* 从接口转换为它的某个实现类型需要显示的强制类型转换

## 7.5 接口继承
* 一个接口可以从另一个接口派生，派生的接口将继承“基接口”的所有成员。

## 7.6 多接口继承
* 接口可以继承多个接口
* 接口一般很少没有成员。但是如果两个接口必须一起实现，这种情况就很正常了。

```c#
interface IFly{
  void Fly();
}
interface IRun{
  void Run();
}
//继承这个接口，必须同时实现IFly、IRun接口
interface ISport:IFly,IRun
{
}
```
## 7.7 接口上的扩展方法
* C#不仅允许为特定类型的实例添加扩展方法，还允许为那些对象的集合添加
* 接口对扩展方法的支持是实现LINQ的基础

> IEnumerable是所有集合都要实现的基本接口，通过为IEnumerable定义扩展方法，为所有集合都添加了LINQ支持。

## 7.8 通过接口实现多继承
* 考虑通过定义接口来获得和多继承相似的效果

## 7.9 版本控制
* 不要为已交付的接口添加成员
* 升级接口可以通过创建第二个接口从原始接口派生

## 7.10 接口与类的比较

| 抽象类                                   | 接口                         |
| :------------------------------------ | :------------------------- |
| 不能直接实例化，只能通过实例化一个派生类                  | 不能直接实例化，只能通过实例化一个实现类型      |
| 派生类要么自己也是抽象的，要么必须实现所有抽象成员             | 实现类型必须实例化所有接口成员            |
| 可添加额外的非抽象成员，它们可有所有派生类继承，而不会破坏版本兼容性    | 为接口添加额外的成员会破坏版本兼容性         |
| 可声明属性和字段                              | 可声明属性但不能声明字段               |
| 成员可以是实例、需、抽象或静态的，而且非抽象成员可提供默认实现供派生类使用 | 所有成员都被自动看成是抽象成员，因此不能包含任何实现 |
| 派生类只能从一个基类派生(单继承)                     | 实现类型可实现任意多的接口              |

> **规范**
> 一般要优先选择类而不是接口。用抽象类将契约(类型做什么)与实现细节(类型怎么做)分离开。
> 想在已从其他类型派生的类型上支持接口所定义的功能时，就考虑定义接口。

## 7.11 接口与特性的比较
* 有时无任何成员(不管是不是继承的)的接口表示类型的信息，称为标记接口(marker interface)，这是对接口机制的“滥用”
* 接口应该用于表示类型能提供的功能，而非陈述关于某个类型的事实
* 避免使用无成员的标记接口，而是使用特性(attributes)