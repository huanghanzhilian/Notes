# 面向对象编程
面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。
```python
class Student(object):
    #__init__方法的第一个参数永远是self，表示创建的实例本身
    def __init__(self, name, score):
        self.name = name
        self.score = score
    #和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self
    def print_score(self):
        print('%s: %s' % (self.name, self.score))
```
面向对象的设计思想是抽象出Class，根据Class创建Instance。

##  类和实例
  类是创建实例的模板，而实例则是一个一个具体的对象，各个实例拥有的数据都互相独立，互不影响；
  方法就是与实例绑定的函数，和普通函数不同，方法可以直接访问实例的数据；
  通过在实例上调用方法，我们就直接操作了对象内部的数据，但无需知道方法内部的实现细节。
  和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同。

## 访问限制
  如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线`__`，在Python中，实例的变量名如果以`__`开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问。

## 继承和多态
```python
class Animal(object):
    def run(self):
        print('Animal is running...')
        
class Dog(Animal):
    def run(self):
        print('Dog is running...')

class Cat(Animal):
    pass
```
对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了。
这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。

## 获取对象信息
  我们来判断对象类型，使用type()函数，基本类型和指向函数或类的变量都可以用type()判断。
  type()函数返回的是对应的Class类型，如果要判断一个对象是否是函数，可以使用types模块中定义的常量
```python
import types
def fn():
    pass

type(fn)==types.FunctionType	#True
type(abs)==types.BuiltinFunctionType	#True
type(lambda x: x)==types.LambdaType		#True
type((x for x in range(10)))==types.GeneratorType	#True
```
对于class的继承关系来说，使用type()就很不方便。我们要判断class的类型，可以使用isinstance()函数。

如果要获得一个对象的所有属性和方法，可以使用dir()函数，它返回一个包含字符串的list。
再配合getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态。
```python
class MyObject(object):
    def __init__(self):
        self.x = 9
        def power(self):
            return self.x * self.x

obj = MyObject()

hasattr(obj, 'x') # 有属性'x'吗？
setattr(obj, 'y', 19) # 设置一个属性'y'
getattr(obj, 'y') # 获取属性'y'

#可以传入一个default参数，如果属性不存在，就返回默认值
getattr(obj, 'z', 404)

#也可以获取对象的方法
fn = getattr(obj, 'power') # 获取属性'power'并赋值到变量fn
```
> 只有在不知道对象信息的时候，我们才会去获取对象信息。
```python
#假设我们希望从文件流fp中读取图像，我们首先要判断该fp对象是否存在read方法，如果存在，则该对象是一个流，如果不存在，则无法读取。hasattr()就派上了用场。
def readImage(fp):
    if hasattr(fp, 'read'):
        return readData(fp)
    return None
```

## 实例属性和类属性
  Python是动态语言，根据类创建的实例可以任意绑定属性。给实例绑定属性的方法是通过实例变量，或者通过self变量
```python
class Student(object):
    def __init__(self, name):
        self.name = name

s = Student('Bob')
s.score = 90
```
在编写程序的时候，千万不要把实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。

## 使用`__slots__`
```python
class Student(object):
    pass
s = Student()
s.name = 'Michael'		#给实例动态绑定属性

def set_age(self, age):
    self.age = age
from types import MethodType
s.set_age = MethodType(set_age, s)	#给实例动态绑定放发，但是只能改实例使用
s.set_age(25)	# 调用实例方法

#为了给所有实例都绑定方法，可以给class绑定方法
def set_score(self, score):
    self.score = score
```
如果要限制实例的属性，比如只允许对Student实例添加name和age属性，Python允许在定义class的时候，定义一个特殊的`__slots__`变量，来限制该class实例能添加的属性。
```python
class Student(object):
    __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称
s = Student()
s.name = 'Michael'
s.score = 99	#会报AttributeError，因为__slots__中没有score
```
> 使用`__slots__`要注意，`__slots__`定义的属性仅对当前类实例起作用，对继承的子类是不起作用的
> 除非在子类中也定义`__slots__`，这样，子类实例允许定义的属性就是自身的__slots__加上父类的`__slots__`

## 使用@property
  Python内置的@property装饰器就是负责把一个方法变成属性调用
```python
class Student(object):

    @property	#相当于c#的get
    def score(self):
        return self._score

    @score.setter	#相当于c#的set，没有的话就是只读属性
    def score(self, value):
        if not isinstance(value, int):
            raise ValueError('score must be an integer!')
        if value < 0 or value > 100:
            raise ValueError('score must between 0 ~ 100!')
        self._score = value
```

## 多重继承
  在设计类的继承关系时，通常，主线都是单一继承下来的，例如，Ostrich继承自Bird。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让Ostrich除了继承自Bird外，再同时继承Runnable。这种设计通常称之为MixIn。
  由于Python允许使用多重继承，因此，MixIn就是一种常见的设计。

## 定制类
  `__str__`类似于c#的ToString()方法
```python
class Student:
    def __init__(self,name):
        self.name=name
    def __str__(self):
        return 'Student object (name:%s)'% self.name
print(Student('Michael'))
#Student object (name: Michael)
```
直接显示变量调用的不是`__str__()`，而是`__repr()__`，两者的区别是__str__()返回用户看到的字符串，而`__repr__()`返回程序开发者看到的字符串，也就是说，`__repr__()`是为调试服务的。
```python
__repr__ = __str__
```

`__iter__`
如果一个类想被用于for ... in循环，类似list或tuple那样，就必须实现一个`__iter__()`方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的`__next__()`方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。
```python
#斐波拉契数列
class Fib():
    def __init__(self):
        self.a,self.b=0,1	#初始化两个计数器a,b
    def __iter__(self):
        return self		#实例本身就是迭代对象，故返回自己
    def __next__(self):
        self.a,self.b=self.b,self.a+self.b		#计算下一个数值
        if self.a>100000:
            raise StopIteration()
        return self.a	#返回下一个值
for n in Fib():
    print(n)
```

`__getitem__`
Fib实例虽然能作用于for循环，看起来和list有点像，但是，把它当成list来使用还是不行，不能按照索引来取值。要实现按照索引来访问元素，需要实现`__getitem__()`方法
```python
class Fib(object):
    def __getitem__(self, n):
        a, b = 1, 1
        for x in range(n):
            a, b = b, a + b
        return a
```

`__getattr__`
动态返回属性，只有在没有找到属性的情况下，才调用`__getattr__`
```python
class Student(object):

    def __init__(self):
        self.name = 'Michael'

    def __getattr__(self, attr):
        if attr=='score':
            return 99
```
利用`__getattr__`动态创建URL
```python
class Chain(object):

    def __init__(self, path=''):
        self._path = path

    def __getattr__(self, path):
        return Chain('%s/%s' % (self._path, path))

    def __str__(self):
        return self._path

    __repr__ = __str__
```

`__call__`
一个对象实例可以有自己的属性和方法，用instance.method()来调用。要调用实例本身，只需要定义一个`__call__()`方法，就可以直接对实例进行调用。
```python
class Student(object):
    def __init__(self, name):
        self.name = name

    def __call__(self):
        print('My name is %s.' % self.name)
```
`__call__()`还可以定义参数。对实例进行直接调用就好比对一个函数进行调用一样。

## 使用枚举
```python
from enum import Enum

Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))

for name, member in Month.__members__.items():
    print(name, '=>', member, ',', member.value)
```
value属性则是自动赋给成员的int常量，默认从1开始计数。

如果需要更精确地控制枚举类型，可以从Enum派生出自定义类：
```python
from enum import Enum, unique
#@unique装饰器可以帮助我们检查保证没有重复值。
@unique
class Weekday(Enum):
    Sun = 0 # Sun的value被设定为0
    Mon = 1
    Tue = 2
    Wed = 3
    Thu = 4
    Fri = 5
    Sat = 6
```

### type()
  type()函数可以查看一个类型或变量的类型，type()函数既可以返回一个对象的类型，又可以创建出新的类型。
```python
def fn(self, name='world'): # 先定义函数
    print('Hello, %s.' % name)
Hello = type('Hello', (object,), dict(hello=fn)) # 创建Hello class
h = Hello()
h.hello()#Hello, world.
```
要创建一个class对象，type()函数依次传入3个参数：
class的名称；继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法；class的方法名称与函数绑定，这里我们把函数fn绑定到方法名hello上。

* metaclass 元类
  先定义metaclass，就可以创建类，最后创建实例。metaclass允许你创建类或者修改类。
```python
# metaclass是类的模板，所以必须从`type`类型派生：
class ListMetaclass(type):
    def __new__(cls, name, bases, attrs):
        attrs['add'] = lambda self, value: self.append(value)
        return type.__new__(cls, name, bases, attrs)
        
#有了ListMetaclass，我们在定义类的时候还要指示使用ListMetaclass来定制类，传入关键字参数metaclass
#它指示Python解释器在创建MyList时，要通过ListMetaclass.__new__()来创建，在此，我们可以修改类的定义，比如，加上新的方法，然后，返回修改后的定义。
class MyList(list, metaclass=ListMetaclass):
    pass
```
`__new__()`方法接收到的参数依次是：当前准备创建的类的对象；类的名字；类继承的父类集合；类的方法集合。

利用metaclass实现简单orm
```python
#Field类，它负责保存数据库表的字段名和字段类型
class Field(object):

    def __init__(self, name, column_type):
        self.name = name
        self.column_type = column_type

    def __str__(self):
        return '<%s:%s>' % (self.__class__.__name__, self.name)
#在Field的基础上，进一步定义各种类型的Field，比如StringField，IntegerField等等    
class StringField(Field):

    def __init__(self, name):
        super(StringField, self).__init__(name, 'varchar(100)')

class IntegerField(Field):

    def __init__(self, name):
        super(IntegerField, self).__init__(name, 'bigint')
        
class ModelMetaclass(type):

    def __new__(cls, name, bases, attrs):
        if name=='Model':
            return type.__new__(cls, name, bases, attrs)
        print('Found model: %s' % name)
        mappings = dict()
        for k, v in attrs.items():
            if isinstance(v, Field):
                print('Found mapping: %s ==> %s' % (k, v))
                mappings[k] = v
        for k in mappings.keys():
            attrs.pop(k)
        attrs['__mappings__'] = mappings # 保存属性和列的映射关系
        attrs['__table__'] = name # 假设表名和类名一致
        return type.__new__(cls, name, bases, attrs)
        
#基类model
class Model(dict, metaclass=ModelMetaclass):

    def __init__(self, **kw):
        super(Model, self).__init__(**kw)

    def __getattr__(self, key):
        try:
            return self[key]
        except KeyError:
            raise AttributeError(r"'Model' object has no attribute '%s'" % key)

    def __setattr__(self, key, value):
        self[key] = value

    def save(self):
        fields = []
        params = []
        args = []
        for k, v in self.__mappings__.items():
            fields.append(v.name)
            params.append('?')
            args.append(getattr(self, k, None))
        sql = 'insert into %s (%s) values (%s)' % (self.__table__, ','.join(fields), ','.join(params))
        print('SQL: %s' % sql)
        print('ARGS: %s' % str(args))
        
class User(Model):
    # 定义类的属性到列的映射：
    id = IntegerField('id')
    name = StringField('username')
    email = StringField('email')
    password = StringField('password')

# 创建一个实例：
u = User(id=12345, name='Michael', email='test@orm.org', password='my-pwd')
# 保存到数据库：
u.save()        
```