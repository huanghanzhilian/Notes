# 高级特性
* 切片
  Python提供了切片（Slice）操作符，取指定索引范围的元素。[start:end:step]
```python
L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']
#取前三个元素
#从索引0开始，直到索引3为止，但不包括索引3
L[0:3]
#['Michael', 'Sarah', 'Tracy']

#同样支持倒数切片
L[-2:]
#['Bob', 'Jack']
L[-2:-1]
#['Bob']

L=list(range(100))
#前10
L[:10]
#后10
L[-10:]
#前11后20
L[10:20]
#前10个数，每两个取一个
L[:10:2]
#所有数，每5个取一个
L[::5]
#什么都不写，可以复制list
L[:]
#step为负数时，代表前面两个索引之间的数据反向取值，前一个索引应该大于后一个索引，倒数索引需转为实际索引来判断大小
print(l[30:20:-1]) #[30, 29, 28, 27, 26, 25, 24, 23, 22, 21]
print(l[20:30:-1]) #[]
```
tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple
字符串'xxx'也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串

```python
#信息补全
name = ['Adam','Alex','Amy','Bob','Boom','Candy','Chris','David','Jason','Jasonstatham','Bill'];
i_name = input("please input name : ").title();
wname = [];
for n in name:
    if n[0:len(i_name)] == i_name:
        wname.append(n);

if len(wname) != 0:
    print('Do you want to find %s?'%(wname));
else:
    print('%s not find'%(i_name));
```

* 迭代
  在Python中，迭代是通过for ... in来完成。
  Python的for循环不仅可以用在list或tuple上，还可以作用在其他可迭代对象上。
  只要是可迭代对象，无论有无下标，都可以迭代。
  可以通过collections模块的Iterable类型来判断是否可迭代
```python
from collections import Iterable
isinstance('abc', Iterable)#True
isinstance([1,2,3], Iterable)#True
isinstance(123, Iterable)#False 整数不可迭代
```
Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身
```python
for i, value in enumerate(['A', 'B', 'C']):
    print(i, value)
#0 A
#1 B
#2 C
#for循环里，同时引用了两个变量，在Python里是很常见的
for x, y in [(1, 1), (2, 4), (3, 9)]:
    print(x,y)
#1 1
#2 4
#3 9
```

* 列表生成式
  写列表生成式时，把要生成的元素x * x放到前面，后面跟for循环，就可以把list创建出来`[x * x for x in range(1, 11)]`
  for循环后面还可以加上if判断`[x * x for x in range(1, 11) if x % 2 == 0]`
  还可以使用两层循环，可以生成全排列`[m + n for m in 'ABC' for n in 'XYZ']`

* 生成器
  在Python中，一边循环一边计算的机制，称为生成器：generator。
  要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator`g = (x * x for x in range(10))`。
  可以通过next()函数访问generator的下一个返回值。
  generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误。
  正确的方法是使用for循环，因为generator也是可迭代对象。
  我们创建了一个generator后，基本上永远不会调用next()，而是通过for循环来迭代它，并且不需要关心StopIteration的错误。
  定义generator的另一种方法。如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator。
  函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。
  但是用for循环调用generator时，发现拿不到generator的return语句的返回值。如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中

```python
#杨辉三角形
def triangles(rowNo):
    i = 1
    row = [1]
    while i <= rowNo:
        yield row
        newPart = [1] + [row[j]+row[j+1] for j in range(len(row)-1)] + [1]
        row = newPart[:]
        i += 1

for i in triangles(10):
    print(i)
```

* 迭代器
可以直接作用于for循环的数据类型有以下几种：一类是集合数据类型，如list、tuple、dict、set、str等；一类是generator，包括生成器和带yield的generator function。
这些可以直接作用于for循环的对象统称为可迭代对象：Iterable，可以使用isinstance()判断一个对象是否是Iterable对象。
生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。把list、dict、str等Iterable变成Iterator可以使用iter()函数：`isinstance(iter('abc'), Iterator)`
Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。