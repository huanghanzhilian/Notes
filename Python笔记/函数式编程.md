# 函数式编程
函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！
Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。

## 高阶函数(Higher-order function)
  变量可以指向函数，函数名也是变量，变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。
```python
def add(x, y, f):
    return f(x) + f(y)
add(5,-6,abs)
```

### map/reduce
  map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。
```python
#map
def f(x):
    return x*x
r=map(f,list(range(10))[1::])
print(list(r))
```
reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：`reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)`
```python
#reduce
from functools import reduce
def add(x, y):
    return x + y
    
print(reduce(add, [1, 3, 5, 7, 9]))
#25
```

利用map/reduce写一个str转成int的函数
```python
from functools import reduce

def str2int(s):
    def fn(x,y):
        return x*10+y
    def char2num(s):
        return {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}[s]
    return reduce(fn,map(char2num,s))
    
#利用lambda简化
def str2int(s):
    return reduce(lambda x, y: x * 10 + y, map(char2num, s))
```

输入：['adam', 'LISA', 'barT']，输出：['Adam', 'Lisa', 'Bart']：
```python
def normalize(name):
    return name[0].upper()+name[1:].lower()
L1 = ['adam', 'LISA', 'barT']
L2 = list(map(normalize, L1))
print(L2)
```

利用reduce求积
```python
from functools import reduce
def prod(L):
    return(reduce(lambda x,y:x*y,L))
print('3 * 5 * 7 * 9 =', prod([3, 5, 7, 9]))
```

利用map和reduce编写一个str2float函数，把字符串'123.456'转换成浮点数123.456
```python
from functools import reduce
def str2float(s):
    return reduce(lambda x,y:10*x+y,map(int,s[:s.find('.')])) + reduce(lambda x,y:x/10 + y,(map(int,s[-1:s.find('.'):-1])))/10
print('str2float(\'123.456\') =', str2float('123.456'))
```

### filter
  Python内建的filter()函数用于过滤序列。和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。

使用filter求素数
```python
#奇数生成器
def _odd_iter():
    n=1
    while True:
        n = n + 2
        yield n
#筛选函数
def _not_divisible(n):
    #返回的是函数，并且有一个位置参数
    return lambda x:x%n>0
#定义生成器，返回素数
def primes():
    yield 2
    it=_odd_iter()
    while True：
        n=next(it)
        yield n
        it = filter(_not_divisible(n),it)
# 打印1000以内的素数:
for n in primes():
    if n < 1000:
        print(n)
    else:
        break
```

### sorted
  Python内置的sorted()函数就可以对list进行排序，此外，sorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序。
```python
#按绝对值大小排序
sorted([36, 5, -12, 9, -21], key=abs)
```
要进行反向排序，不必改动key函数，可以传入第三个参数reverse=True
```python
sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)
```

## 函数作为返回值
  高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。
```python
def lazy_sum(*args):
    def sum():
        ax = 0
        for n in args:
            ax = ax + n
        return ax
    return sum

f = lazy_sum(1, 3, 5, 7, 9)
#调用lazy_sum()时，返回的并不是求和结果，而是求和函数
f	#<function lazy_sum.<locals>.sum at 0x101c6ed90>
f()	#25,调用函数f时，才真正计算求和的结果
```
> 在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。
> 当我们调用lazy_sum()时，每次调用都会返回一个新的函数，即使传入相同的参数。

### 闭包
  注意到返回的函数在其定义内部引用了局部变量args，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。
```python
def count():
    fs = []
    for i in range(1, 4):
        def f():
             return i*i
        fs.append(f)
    return fs

f1, f2, f3 = count()

f1()	#9
f2()	#9
f3()	#9
```
返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。
如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变。
```python
def count():
    def f(j):
        def g():
            return j*j
        return g
    fs = []
    for i in range(1, 4):
        fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()
    return fs
```

## 装饰器
  函数对象有一个`__name__`属性，可以拿到函数的名字
  如果我们想增强函数的功能，又不希望修改函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”(Decorator)。
  本质上，decorator就是一个返回函数的高阶函数。所以，我们要定义一个能打印日志的decorator，可以定义如下：
```python
#接受一个函数作为参数，并返回一个函数
def log(func):
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper
```
借助Python的@语法，把decorator置于函数的定义处
```python
@log
def now():
    print('2015-3-25')
```
把@log放到now()函数的定义处，相当于执行了语句：`now = log(now)`
log()是一个decorator，返回一个函数，所以，原来的now()函数仍然存在，只是现在同名的now变量指向了新的函数，于是调用now()将执行新函数，即在log()函数中返回的wrapper()函数。
如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数，写出来会更复杂。
```python
def log(text):
    def decorator(func):
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
```
完整的decorator的写法如下
```python
import functools

def log(func):
    @functools.wraps(func)
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper
    
#带参数的
def log(text):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
```

## 偏函数
  Python的functools模块提供了很多有用的功能，其中一个就是偏函数（Partial function）。
  functools.partial就是帮助我们创建一个偏函数的，不需要我们自己定义int2()，可以直接使用下面的代码创建一个新的函数int2：
```python
import functools
int2 = functools.partial(int, base=2)
int2('1000000') #64
```
functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。
创建偏函数时，实际上可以接收函数对象、`*args`和`**kw`这3个参数
```python
int2('10010')
#相当于
kw = { 'base': 2 }
int('10010', **kw)

max2 = functools.partial(max, 10)
#会把10作为*args的一部分自动加到左边
max2(5, 6, 7)
#相当于
args = (10, 5, 6, 7)
max(*args)
#结果为10
```